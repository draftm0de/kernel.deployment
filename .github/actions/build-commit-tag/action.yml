name: "Build Commit Version Tags"
description: "Build Commit Version Tags"
inputs:
  source:
    description: "source branch name"
    required: true
  target:
    description: "branch to be merged into"
    required: true
  image:
    description: "Docker image without tag"
    required: true
  digest:
    description: "Docker image digest"
    required: true

outputs:
  tag:
    description: "tag to be use for commit"
    value: ${{ steps.get-commit-tag.outputs.tag }}

runs:
  using: "composite"
  steps:
    - name: "Convert Target Branch To Version"
      id: target
      uses: draftm0de/kernel.deployment/.github/actions/convert-branch-to-version@main
      with:
        branch: ${{ inputs.target }}

    - name: "Convert Source Branch To Version"
      id: source
      uses: draftm0de/kernel.deployment/.github/actions/convert-branch-to-version@main
      with:
        branch: ${{ inputs.source }}

    - name: "Get Target Branch Image Digest"
      if: ${{ steps.target.outputs.branch != '' && steps.source.outputs.branch == '' }}
      id: target-image-digest
      uses: draftm0de/kernel.deployment/.github/actions/image-manifest-property@main
      with:
        image: ${{ inputs.image }}
        property: ".config.digest"

    - name: "Compare Image Digest"
      if: ${{ steps.target.outputs.branch != '' && steps.source.outputs.branch == '' }}
      shell: bash
      run: |
        echo "::notice::Comparing Image Digest..."
        remote_digest="${{ steps.target-image-digest.outputs.digest }}"
        build_digest="${{ inputs.digest }}"
        echo "::notice::>remote: $remote_digest"
        echo "::notice::>build: $build_digest"
        echo "::notice::Image digest compared."

    - name: "Validate Source and Target branch"
      if: ${{ env.SKIP_STEP != 'true' }}
      shell: bash
      run: |
        echo "::notice::Validating source and target branch..."
        if [ -n "${{ steps.source.outputs.branch }}" ]; then
          echo "::warning::source branch matches version patterns, skip commit tagging"
          echo "SKIP_STEP=true" >> $GITHUB_ENV
          exit 0
        else
          echo "::notice::> source branch does not match version pattern"
        fi 
        if [ -z "${{ steps.target.outputs.branch }}" ]; then
          echo "::warning::target branch does not match version patterns, skip commit tagging"
          echo "SKIP_STEP=true" >> $GITHUB_ENV
          exit 0
        else
          echo "::notice::> target branch matches version patterns"
        fi
        echo "::notice::source and target branch validated."

    - name: "Ensure commit does not have any version tag"
      if: ${{ env.SKIP_STEP != 'true' }}
      shell: bash
      run: |
        echo "::notice::Protecting version tags..."
        git fetch --tags
        
        # Get all tags for the current commit
        current_commit=$(git rev-parse HEAD)
        tags=$(git tag --contains "$current_commit")
        
        # Filter tags matching the regex
        regex="^(v)?([0-9]+)(\.[0-9]+)?(\.[0-9]+)?(-[a-zA-Z0-9]+)?$"
        matching_tags=()
        while IFS= read -r tag; do
          if [[ $tag =~ $regex ]]; then
            echo "::error::> commit already has a version tag: $tag"
            exit 1
          fi
        done <<< "$tags"
        echo "::notice::Version tags protected."

    - name: "Build commit tag"
      if: ${{ env.SKIP_STEP != 'true' }}
      shell: bash
      id: build-commit-tag
      run: |
        echo "::notice::Build Commit Tag..."
        
        pattern="${{ steps.target.outputs.prefix }}${{ steps.target.outputs.major }}"
        if [ -n "${{ steps.target.outputs.minor }}" ]; then
          pattern="${pattern}.${{ steps.target.outputs.minor }}"
        fi
        commit_tag="$pattern"
        if [ -n "${{ steps.target.outputs.postfix }}" ]; then
          pattern="${pattern}.*-${{ steps.target.outputs.minor }}"
        else
          pattern="${pattern}.*"
        fi        
        echo "::notice::> search pattern: $pattern"
        
        latest_tag=$(git tag --list "${pattern}" --sort=-v:refname | head -n 1)
        
        # determine the new tag
        if [ -z "$latest_tag" ]; then
          echo "::notice::> latest tag: no latest tag"          
          commit_tag="${commit_tag}.1${{ steps.target.outputs.postfix }}"
        else
          echo "::notice::> latest tag: $latest_tag"
        
          # Increment the patch version
          patch_version=${latest_tag##*.}
          new_patch_version=$((patch_version + 1))        
          commit_tag="${commit_tag}.${patch_version}${{ steps.target.outputs.postfix }}"
        fi
        echo "::notice::Commit tag built: $commit_tag"
        echo "tag=${commit_tag}" >> $GITHUB_OUTPUT

    - name: "Ensure tag is not an existing branch"
      if: ${{ steps.build-commit-tag.outputs.tag }}
      shell: bash
      id: get-commit-tag
      run: |
        echo "::notice::Approving Commit Tag..."
        tag="${{ steps.build-commit-tag.outputs.tag }}"
        echo "::notice::> tag: $tag"
        if git ls-remote --exit-code --heads origin $tag; then
          echo "::error::commit tag already exists as branch"
        else
          echo "::notice::Commit tag approved."
          echo "tag=${tag}" >> $GITHUB_OUTPUT
        fi
