name: "Build Commit Version Tags"
description: "Build Commit Version Tags"
inputs:
  source:
    description: "source branch name"
    required: true
  target:
    description: "target branch name"
    required: true

outputs:
  commit_tag:
    description: "tag to be use for commit"
    value: ${{ steps.get-commit-tag.outputs.tag }}

runs:
  using: "composite"
  steps:
    - name: "Convert target branch into version"
      shell: bash
      id: target
      uses: draftm0de/kernel.deployment/.github/actions/convert-branch-to-version@main
      with:
        branch: ${{ inputs.target }}

    - name: "Convert source branch into version"
      shell: bash
      id: source
      uses: draftm0de/kernel.deployment/.github/actions/convert-branch-to-version@main
      with:
        branch: ${{ inputs.source }}

    - name: "Validate source and target branch"
      shell: bash
      run: |
        if [ "${{ steps.source.outputs.branch }}" == "${{ source.target }}" ]; then
          echo "::warning:: source branch matches version patterns, skip commit tagging"
          exit 0
        fi 
        if [ "${{ steps.target.outputs.branch }}" == "-" ]; then
          echo "::warning:: target branch does not matches version patterns, skip commit tagging"
          exit 0
        fi

    - name: "Ensure commit does not have any version tag"
      shell: bash
      run: |
        git fetch --tags
        
        # Get all tags for the current commit
        current_commit=$(git rev-parse HEAD)
        tags=$(git tag --contains "$current_commit")
        
        # Filter tags matching the regex
        regex="^(v)?([0-9]+)(\.[0-9]+)?(\.[0-9]+)?(-[a-zA-Z0-9]+)?$"
        matching_tags=()
        while IFS= read -r tag; do
          if [[ $tag =~ $regex ]]; then
            echo "::error:: > commit already has a version tag: $tag"
            exit 1
          fi
        done <<< "$tags"

    - name: "Build commit tag"
      shell: bash
      id: build-commit-tag
      run: |
        echo "::notice:: Build Commit Tag..."
        
        pattern="${{ steps.target.outputs.prefix }}${{ steps.target.outputs.major }}"
        if [ -n "${{ steps.target.outputs.minor }}" ]; then
          pattern="${pattern}.${{ steps.target.outputs.minor }}"
        fi
        commit_tag="$pattern"
        if [ -n "${{ steps.target.outputs.postfix }}" ]; then
          pattern="${pattern}.*-${{ steps.target.outputs.minor }}"
        else
          pattern="${pattern}.*"
        fi        
        echo "**notice** > search pattern: $pattern"
        
        latest_tag=$(git tag --list "${pattern}" --sort=-v:refname | head -n 1)
        
        # determine the new tag
        if [ -z "$latest_tag" ]; then
          echo "::notice:: > latest tag: no latest tag"          
          commit_tag="${commit_tag}.1${{ steps.target.outputs.postfix }}"
        else
          echo "::notice:: > latest tag: $latest_tag"
        
          # Increment the patch version
          patch_version=${latest_tag##*.}
          new_patch_version=$((patch_version + 1))        
          commit_tag="${commit_tag}.${patch_version}${{ steps.target.outputs.postfix }}"
        fi
        echo "::notice:: Commit tag built: $commit_tag"
        echo "tag=${commit_tag}" >> $GITHUB_OUTPUT

    - name: "Ensure tag is not an existing branch"
      if: ${{ steps.build-commit-tag.tag }}
      shell: bash
      id: get-commit-tag
      run: |
        echo "::notice:: Approving Commit Tag..."
        tag="${{ steps.build-commit-tag.tag }}"
        if git ls-remote --exit-code --heads origin $tag; then
          echo "::error:: commit tag $tag already exists as branch"
        else
          echo "::notice:: Commit tag approved."
          echo "tag=${tag}" >> $GITHUB_OUTPUT
        fi
