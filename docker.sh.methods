#!/bin/bash

# ########################################
# string methods
# ########################################
.filter_image_tags() {
  local OPTION="${1}"
  local TAGS_LIST="${2}"
  read -r -a TAGS <<< "$TAGS_LIST"
  case "$OPTION" in
    major)
      printf "%s\n" "${TAGS[@]}" | grep -E '^[0-9]+$' | sort -Vr
    ;;
    minor)
      printf "%s\n" "${TAGS[@]}" | grep -E '^[0-9]+\.[0-9]+$' | sort -Vr
    ;;
    patch)
      printf "%s\n" "${TAGS[@]}" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -Vr
    ;;
    *)
      echo "[Error] OPTION ${OPTION} for image tags [IMAGE] --latest=[OPTION] invalid, supported: major, minor, patch, <empty=patch>" >&2
      exit 1
  esac
}

.increment_image_tag() {
  local VERSION="${1}"
  local BASE_VERSION="${2}"
  local NEW_VERSION

  local MAJOR_BASE
  local MINOR_BASE

  MAJOR_VERSION=$(echo "$VERSION" | cut -d. -f1)
  MINOR_VERSION=$(echo "$VERSION" | cut -d. -f2)

  if [ -n "$BASE_VERSION" ]; then
    # no TARGET_IMAGE:[TAG] given
    if [ -z "$VERSION" ]; then
      echo "$BASE_VERSION"
      return
    fi
    MAJOR_BASE=$(echo "$BASE_VERSION" | cut -d. -f1)
    MINOR_BASE=$(echo "$BASE_VERSION" | cut -d. -f2)
    if [[ $MAJOR_BASE -gt $MAJOR_VERSION ]]; then
      if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "$MAJOR_BASE.$MINOR_BASE.1"
          return
      elif [[ "$VERSION" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "$MAJOR_BASE.$MINOR_BASE"
        return
      fi
    fi
    if [[ $MAJOR_BASE -lt $MAJOR_VERSION ]]; then
      echo "[Error] --tag-increase=$BASE_VERSION major version conflict: $BASE_VERSION cannot be lower then given TARGET_IMAGE:[TAG] tag $VERSION" >&2
      exit 1
    fi
    if [[ $MINOR_BASE -gt $MINOR_VERSION ]]; then
      if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "$MAJOR_BASE.$MINOR_BASE.1"
          return
      elif [[ "$VERSION" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "$MAJOR_BASE.$MINOR_BASE"
        return
      fi
    fi
    if [[ $MINOR_BASE -lt $MINOR_VERSION ]]; then
      echo "[Error] --tag-increase=$BASE_VERSION minor version conflict: $BASE_VERSION cannot be lower then given TARGET_IMAGE:[TAG] tag $VERSION" >&2
      exit 1
    fi
  fi

  # Check if the version has the patch part (X.Y.Z format)
  if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    local PATCH_VERSION
    # Extract base version (X.Y) and patch version (Z)
    PATCH_VERSION=$(echo "$VERSION" | cut -d. -f3)

    # Increment the patch version (Z)
    PATCH_VERSION=$((PATCH_VERSION + 1))

    # Construct the new version as X.Y.(Z+1)
    NEW_VERSION="$MAJOR_VERSION.$MINOR_VERSION.$PATCH_VERSION"
  # Check if the version is in X.Y format
  elif [[ "$VERSION" =~ ^[0-9]+\.[0-9]+$ ]]; then
    local MAJOR_VERSION
    local MINOR_VERSION

    # Extract major (X) and minor (Y)
    MAJOR_VERSION=$(echo "$VERSION" | cut -d. -f1)
    MINOR_VERSION=$(echo "$VERSION" | cut -d. -f2)

    # Increment the minor version (Y)
    MINOR_VERSION=$((MINOR_VERSION + 1))

    # Construct the new version as X.(Y+1)
    NEW_VERSION="$MAJOR_VERSION.$MINOR_VERSION"
  fi
  echo "$NEW_VERSION"
}
.get_image_tag_level() {
  local TAG="${1}"
  local LEVEL="${2}"

  local MAJOR MINOR
  MAJOR=$(echo "$TAG" | cut -d. -f1)
  MINOR=$(echo "$TAG" | cut -d. -f2)

  if [[ "$LEVEL" -gt 3 ]]; then
    echo "[Error] --tag-level=$LEVEL cannot be greater than 3" >&2
    exit 1
  elif [[ "$LEVEL" -eq 3 ]]; then
    if [ "$TAG" = "$MAJOR" ]; then
      echo "[Error] --tag-level=$LEVEL requires a PATCH leveled TAG, given tag: $TAG " >&2
      exit 1
    elif [ "$TAG" = "$MAJOR.$MINOR" ]; then
      echo "[Error] --tag-level=$LEVEL requires a PATCH leveled TAG, given tag: $TAG " >&2
      exit 1
    fi
    TAGS=("$TAG" "$MAJOR.$MINOR" "$MAJOR")
  elif [[ "$LEVEL" -eq 2 ]]; then
    if [ "$TAG" == "$MAJOR" ]; then
      echo "[Error] --tag-level=$LEVEL requires a MINOR leveled TAG, given tag: $TAG " >&2
      exit 1
    fi
    TAGS=("$MAJOR.$MINOR" "$MAJOR")
  else
    TAGS=("$TAG")
  fi

  echo "${TAGS[*]}"
}
.get_incremented_image_tag() {
  local TARGET_IMAGE="${1}"
  local BASE_TAG="${2}"

  # split image into name + tag
  TARGET_NAME="${TARGET_IMAGE%%:*}"
  TARGET_TAG="${TARGET_IMAGE#*:}"
  if [ "$TARGET_NAME" == "$TARGET_TAG" ]; then
    TARGET_TAG=""
  fi

  local NEW_VERSION
  if [ "$BASE_TAG" == "true" ]; then
    if [ -z "$TARGET_TAG" ]; then
      echo "[Error] --tag-increase without any BASE_TAG requires a TARGET_IMAGE:TAG" >&2
      exit 1
    fi
    BASE_TAG=""
  fi

  # Regular expression to find the version (X.Y or X.Y.Z)
  local TAG_REGEX="[0-9]+\.[0-9]+(\.[0-9]+)?"
  local CLEAN_TARGET_TAG
  if [[ "$TARGET_TAG" =~ $TAG_REGEX ]]; then
    CLEAN_TARGET_TAG=$(echo "$TARGET_TAG" | grep -oE "$TAG_REGEX")
  else
    if [ -n "$TARGET_TAG" ]; then
      echo "[Error] no valid version number in $TARGET_IMAGE found" >&2
      exit 1
    fi
    CLEAN_TARGET_TAG=$TARGET_TAG
  fi

  NEW_VERSION=$(.increment_image_tag "$CLEAN_TARGET_TAG" "$BASE_TAG")
  EXIT=$?
  if [ $EXIT -ne 0 ]; then
    exit $EXIT
  fi

  if [ -n "$NEW_VERSION" ]; then
    if [ -n "$TARGET_TAG" ]; then
      # Replace the old version with the new version in the BASE string
      local NEW_TAG
      NEW_TAG=$(echo "$TARGET_TAG" | sed "s/$CLEAN_TARGET_TAG/$NEW_VERSION/")
      echo "$NEW_TAG"
    else
      echo "$NEW_VERSION"
    fi
  fi
}

