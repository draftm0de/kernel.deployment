#!/bin/bash

# ########################################
# docker secret methods
# ########################################
.docker_config_get_auth() {
  local POSITION=${1:-1}
  local DOCKER_JSON_FILE DECODED_AUTH VALUE
  DECODED_AUTH=$(.docker_get_config_auth_context "$DOCKER_JSON_PATH")
  if [ -n "$DECODED_AUTH" ]; then
    VALUE=$(echo "$DECODED_AUTH" | cut -d':' -f$POSITION)
    if [ -n "$VALUE" ]; then
      echo "$VALUE"
    fi
  fi
}

.docker_get_config_file() {
  FILES=("$HOME/.docker/config.json" "/etc/docker/config.json")
  for FILE in "${FILES[@]}"; do
    if [ -f  "${FILE}" ]; then
      echo "${FILE}"
    fi
  done
}

.docker_get_config_auth_context() {
  DOCKER_JSON_FILE=$(.docker_get_config_file)
  if [ -f "$DOCKER_JSON_FILE" ]; then
    local AUTH_PATTERN_1='."https://index.docker.io/v1/".auth'
    local AUTH_PATTERN_2='.auths."https://index.docker.io/v1/".auth'

    # Check the first pattern
    AUTH_FIELD=$(jq -r "$AUTH_PATTERN_1" "$DOCKER_JSON_FILE")
    if [ -n "$AUTH_FIELD" ] && [ "$AUTH_FIELD" != "null" ]; then
      DECODED=$(echo "$AUTH_FIELD" | base64 --decode)
      echo "$DECODED"
      return
    fi

    # Check the second pattern
    AUTH_FIELD=$(jq -r "$AUTH_PATTERN_2" "$DOCKER_JSON_FILE")
    if [ -n "$AUTH_FIELD" ] && [ "$AUTH_FIELD" != "null" ]; then
      DECODED=$(echo "$AUTH_FIELD" | base64 --decode)
      echo "$DECODED"
      return
    fi
  fi
}

# ########################################
# string methods
# ########################################
.parse_arguments() {
  local -a remaining_args=()
  local remote="docker.local"

  for arg in "$@"; do
    case "$arg" in
      --remote=*)
        remote="${arg#*=}"
        ;;
      --remote)
        remote="docker.hub"
        ;;
      --build-args=*)
        BUILD_ARG_FILE="${arg##*=}"
        if [ -f "$BUILD_ARG_FILE" ]; then
          # shellcheck disable=SC2002
          BUILD_ARGS=$(cat "$BUILD_ARG_FILE" | awk -F "=" '{ print "--build-arg " $1"="$2;}' | xargs)
          remaining_args+=("${BUILD_ARGS[@]}")
        else
          echo "[Error] --build-args=$BUILD_ARG_FILE does not exists" >&2
          exit 1
        fi
      ;;
      *)
        remaining_args+=("$arg")
        ;;
    esac
  done
  echo "$remote" "${remaining_args[@]}"
}

.get_option_from_arguments() {
  local OPTION="${1}"
  # shellcheck disable=SC2206
  local ARGS=(${2})
  local OPTION_DEFAULT="${3}"

  for arg in "${ARGS[@]}"; do
     case "$arg" in
      "${OPTION}")
        echo "$OPTION_DEFAULT"
        return
      ;;
      "${OPTION}="*)
        local OPTION_DEFAULT="${arg##*=}"
        echo "$OPTION_DEFAULT"
        return
      ;;
      *)
      ;;
     esac
     shift
  done
  echo ""
}

.get_image_names_from_arguments() {
  IMAGE_NAME=()
  # shellcheck disable=SC2206
  ARGS=(${1})
  for arg in "${ARGS[@]}"; do
    case "$arg" in
      -*)
        # Skip arguments that start with a dash (-)
        ;;
      *)
        IMAGE_NAME+=("$arg")
        ;;
    esac
    shift
  done
  echo "${IMAGE_NAME[@]}"
}

.filter_image_tags() {
  local OPTION="${1}"
  local TAGS_LIST="${2}"
  read -r -a TAGS <<< "$TAGS_LIST"
  case "$OPTION" in
    major)
      printf "%s\n" "${TAGS[@]}" | grep -E '^[0-9]+$' | sort -Vr
    ;;
    minor)
      printf "%s\n" "${TAGS[@]}" | grep -E '^[0-9]+\.[0-9]+$' | sort -Vr
    ;;
    patch)
      printf "%s\n" "${TAGS[@]}" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -Vr
    ;;
    *)
      echo "[Error] OPTION ${OPTION} for image tags [IMAGE] --latest=[OPTION] invalid, supported: major, minor, patch, <empty=patch>" >&2
      exit 1
  esac
}

.compare_image_sha() {
  local OPTION="${1}"
  local IMAGE="${2}"
  local REMOTE_SHA="${3}"
  LOCAL_SHA=$(docker inspect --format="{{.Id}}" "$IMAGE")
  EXIT=$?
  if [ $EXIT -ne 0 ]; then
    exit $EXIT
  fi
  if [ "$LOCAL_SHA" == "$REMOTE_SHA" ]; then
    if [ "$OPTION" == "eq" ]; then
      exit 0
    else
      echo "[Error] sha for $IMAGE: remote is equal to local" >&2
      exit 1
    fi
  else
    if [ "$OPTION" == "eq" ]; then
      echo "[Error] sha for $IMAGE: remote is not equal to local" >&2
      exit 1
    else
      exit 0
    fi
  fi
}

.increment_image_tag() {
  local VERSION="${1}"
  local BASE_VERSION="${2}"
  local NEW_VERSION

  local MAJOR_BASE
  local MINOR_BASE

  MAJOR_VERSION=$(echo "$VERSION" | cut -d. -f1)
  MINOR_VERSION=$(echo "$VERSION" | cut -d. -f2)

  if [ -n "$BASE_VERSION" ]; then
    # no TARGET_IMAGE:[TAG] given
    if [ -z "$VERSION" ]; then
      echo "$BASE_VERSION"
      return
    fi
    MAJOR_BASE=$(echo "$BASE_VERSION" | cut -d. -f1)
    MINOR_BASE=$(echo "$BASE_VERSION" | cut -d. -f2)
    if [[ $MAJOR_BASE -gt $MAJOR_VERSION ]]; then
      if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "$MAJOR_BASE.$MINOR_BASE.1"
          return
      elif [[ "$VERSION" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "$MAJOR_BASE.$MINOR_BASE"
        return
      fi
    fi
    if [[ $MAJOR_BASE -lt $MAJOR_VERSION ]]; then
      echo "[Error] --tag-increase=$BASE_VERSION major version conflict: $BASE_VERSION cannot be lower then given TARGET_IMAGE:[TAG] tag $VERSION" >&2
      exit 1
    fi
    if [[ $MINOR_BASE -gt $MINOR_VERSION ]]; then
      if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "$MAJOR_BASE.$MINOR_BASE.1"
          return
      elif [[ "$VERSION" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "$MAJOR_BASE.$MINOR_BASE"
        return
      fi
    fi
    if [[ $MINOR_BASE -lt $MINOR_VERSION ]]; then
      echo "[Error] --tag-increase=$BASE_VERSION minor version conflict: $BASE_VERSION cannot be lower then given TARGET_IMAGE:[TAG] tag $VERSION" >&2
      exit 1
    fi
  fi

  # Check if the version has the patch part (X.Y.Z format)
  if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    local PATCH_VERSION
    # Extract base version (X.Y) and patch version (Z)
    PATCH_VERSION=$(echo "$VERSION" | cut -d. -f3)

    # Increment the patch version (Z)
    PATCH_VERSION=$((PATCH_VERSION + 1))

    # Construct the new version as X.Y.(Z+1)
    NEW_VERSION="$MAJOR_VERSION.$MINOR_VERSION.$PATCH_VERSION"
  # Check if the version is in X.Y format
  elif [[ "$VERSION" =~ ^[0-9]+\.[0-9]+$ ]]; then
    local MAJOR_VERSION
    local MINOR_VERSION

    # Extract major (X) and minor (Y)
    MAJOR_VERSION=$(echo "$VERSION" | cut -d. -f1)
    MINOR_VERSION=$(echo "$VERSION" | cut -d. -f2)

    # Increment the minor version (Y)
    MINOR_VERSION=$((MINOR_VERSION + 1))

    # Construct the new version as X.(Y+1)
    NEW_VERSION="$MAJOR_VERSION.$MINOR_VERSION"
  fi
  echo "$NEW_VERSION"
}
.get_image_tag_level() {
  local TAG="${1}"
  local LEVEL="${2}"

  local MAJOR MINOR
  MAJOR=$(echo "$TAG" | cut -d. -f1)
  MINOR=$(echo "$TAG" | cut -d. -f2)

  TAGS=("$TAG")
  if [[ "$LEVEL" -gt 3 ]]; then
    echo "[Error] --tag-level=$LEVEL cannot be greater than 3" >&2
    exit 1
  elif [[ "$LEVEL" -eq 3 ]]; then
    if [ "$TAG" != "$MAJOR.$MINOR" ]; then
      TAGS+=("$MAJOR.$MINOR")
    fi
    TAGS+=("$MAJOR")
  elif [[ "$LEVEL" -eq 2 ]]; then
    if [ "$TAG" == "$MAJOR.$MINOR" ]; then
      TAGS+=("$MAJOR")
    else
      TAGS+=("$MAJOR.$MINOR")
    fi
  fi

  echo "${TAGS[*]}"
}
.get_incremented_image_tag() {
  local TARGET_IMAGE="${1}"
  local BASE_TAG="${2}"

  # split image into name + tag
  TARGET_NAME="${TARGET_IMAGE%%:*}"
  TARGET_TAG="${TARGET_IMAGE#*:}"
  if [ "$TARGET_NAME" == "$TARGET_TAG" ]; then
    TARGET_TAG=""
  fi

  local NEW_VERSION
  if [ "$BASE_TAG" == "true" ]; then
    if [ -z "$TARGET_TAG" ]; then
      echo "[Error] --tag-increase without any BASE_TAG requires a TARGET_IMAGE:TAG" >&2
      exit 1
    fi
    BASE_TAG=""
  fi

  # Regular expression to find the version (X.Y or X.Y.Z)
  local TAG_REGEX="[0-9]+\.[0-9]+(\.[0-9]+)?"
  local CLEAN_TARGET_TAG
  if [[ "$TARGET_TAG" =~ $TAG_REGEX ]]; then
    CLEAN_TARGET_TAG=$(echo "$TARGET_TAG" | grep -oE "$TAG_REGEX")
  else
    if [ -n "$TARGET_TAG" ]; then
      echo "[Error] no valid version number in $TARGET_IMAGE found" >&2
      exit 1
    fi
    CLEAN_TARGET_TAG=$TARGET_TAG
  fi

  NEW_VERSION=$(.increment_image_tag "$CLEAN_TARGET_TAG" "$BASE_TAG")
  EXIT=$?
  if [ $EXIT -ne 0 ]; then
    exit $EXIT
  fi

  if [ -n "$NEW_VERSION" ]; then
    if [ -n "$TARGET_TAG" ]; then
      # Replace the old version with the new version in the BASE string
      local NEW_TAG
      NEW_TAG=$(echo "$TARGET_IMAGE" | sed "s/$CLEAN_TARGET_TAG/$NEW_VERSION/")
      echo "$NEW_TAG"
    else
      echo "$NEW_VERSION"
    fi
  fi
}

